/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. eg2.jj */
/*@egen*//* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */


options {
             
  KEEP_LINE_COLUMN = false;
  STATIC = false;
}

PARSER_BEGIN(Eg2)

/** An Arithmetic Grammar. */
//package Parser;
import symbols.*;

public class Eg2/*@bgen(jjtree)*/implements Eg2TreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTEg2State jjtree = new JJTEg2State();

/*@egen*/
	Env curEnv = null;       // current symbol table
	/** Main entry point. */
	public static void main(String args[])
	{
	  	System.out.println("Reading from standard input...");
	    Eg2 t = new Eg2(System.in);
	    try
	    {
	      ASTStart n = t.Start();
	      n.dump("");
	      System.out.println("Thank you.");
	    } catch (Exception e)
	    {
	      System.out.println("Oops.");
	      System.out.println(e.getMessage());
	      e.printStackTrace();
	    }
	}
}

PARSER_END(Eg2)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : /* KEYWORD  */
{
	<IF: "if" >
	| <ELSE: "else" >
	| <FOR: "for" >
	| <TO: "to" >
	| <WHILE: "while" >
	| <FOREACH: "foreach" >
	| <BREAK: "break" >
	| <CONTINUE: "continue" >
	| <STRUCT: "struct" >
	| <RETURN: "return" >
}


TOKEN : /* KEYWORD  */
{
  	
	<VARIABLE_TYPE:  <BOOL > | <INT > | <CHAR > | <REAL >>
	| <CONST: "const" >
	| <#BOOL: "bool" >
	| <#INT: "int" >
	| <#CHAR: "char" >
	| <#REAL: "real" >
	| <VOID: "void" >
}


TOKEN : /* LITERAL  */
{
  	<INTEGER_LITERAL:
		<DECIMAL_NUMERAL >
		| <HEX_NUMERAL >
		| <OCTAL_NUMERAL >
	>
	| <REAL_LITERAL:
		(<DECIMAL_NUMERAL > "." <DECIMAL_NUMERAL >)
		| ("." <DECIMAL_NUMERAL >)
		| (<DECIMAL_NUMERAL > ".")
	>
	| <BOOLEAN_LITERAL: "true" | "false" >
	| <NULL_LITERAL: "null" >
	| <CHARACTER_LITERAL: ("\'" ["a"-"z", "A"-"Z", "1"-"9"] "\'") >
	| <#NON_ZERO_DIGIT: ["1"-"9"] >
	| <#DIGIT: "0" | <NON_ZERO_DIGIT > >
	| <#DIGITS: (<DIGIT >)* >
	| <#DECIMAL_NUMERAL:
		"0"
		|<NON_ZERO_DIGIT ><DIGITS >
	>
	| <#HEX_DIGIT: ["0"-"9", "a"-"f", "A"-"F"] >	
	| <#HEX_NUMERAL: ("0" ["x", "X"] (<HEX_DIGIT >)+) >
	| <#OCTAL_DIGIT: ["0"-"7"] >
	| <#OCTAL_NUMERAL: ("0" (<OCTAL_DIGIT >)+) >	}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
}

TOKEN : /* ASSIGNMENT OPERATORS */
{
  	<ASSIGNMENT_EQUAL_OPERATOR: "=" >
	| <ASSIGNMENT_OPERATOR:
		"*="
		| "/="
		| "+="
		| "-="
		| "<<="
		| ">>="
		| "&="
		| "^="
		| "|="
	>}



/** Main production. */
ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	{		
		curEnv = new Env(null);
	}
	
	( StructDeclaration() | LOOKAHEAD(3)FunctionDeclarator() | LOOKAHEAD(3)UniversalDeclarator())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** ************Declarations*************** .*/

/** array initializer. */
void ArrayInitializer() : {/*@bgen(jjtree) ArrayInitializer */
  ASTArrayInitializer jjtn000 = new ASTArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayInitializer */
        try {
/*@egen*/
	Expression() ("," Expression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UniversalDeclarator() : 
{/*@bgen(jjtree) UniversalDeclarator */
        ASTUniversalDeclarator jjtn000 = new ASTUniversalDeclarator(JJTUNIVERSALDECLARATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t = null;
	String id;
	Type type;
	int paraR;
}
{/*@bgen(jjtree) UniversalDeclarator */
        try {
/*@egen*/
	(<CONST >)? t = <VARIABLE_TYPE > id = MyID()
	{
		jjtn000.setName(t.image);
		jjtn000.setId(id);
		if (curEnv.contains(id))
			throw new ParseException("Redifine: "+ id);
		String s = t.image;
		if (s.compareTo("int") == 0)
			type = Type.Int;
		else if (s.compareTo("bool") == 0)
			type = Type.Bool;
		else if (s.compareTo("real") == 0)
			type = Type.Real;
		else if (s.compareTo("char") == 0)
			type = Type.Char;
		else
			throw new ParseException("Unknow type");
		curEnv.put(id, type);
	}	
	(
		<ASSIGNMENT_EQUAL_OPERATOR > paraR = Expression()
		{
		  	jjtn000.genInter(0, paraR);
		  	
			if ((type == Type.Bool) && (jjtn000.typeRight != Type.Bool))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
			if ((type != Type.Bool) && (jjtn000.typeRight == Type.Bool))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
			if ((type == Type.Char) && (jjtn000.typeRight == Type.Real))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
			if ((type == Type.Int) && (jjtn000.typeRight == Type.Real))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);		}
	|
		"[" (<INTEGER_LITERAL >)? "]" (<ASSIGNMENT_EQUAL_OPERATOR > "{" ArrayInitializer() "}")?
	)?
	(
		"," id = MyID()
		{
		  	jjtn000.setId(id);
			if (curEnv.contains(id))
				throw new ParseException("Redifine: "+ id);
			curEnv.put(id, type);		}
		(
		<ASSIGNMENT_EQUAL_OPERATOR > paraR = Expression()
		{
		  	jjtn000.genInter(0, paraR);
		  	
			if ((type == Type.Bool) && (jjtn000.typeRight != Type.Bool))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
			if ((type != Type.Bool) && (jjtn000.typeRight == Type.Bool))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
			if ((type == Type.Char) && (jjtn000.typeRight == Type.Real))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
			if ((type == Type.Int) && (jjtn000.typeRight == Type.Real))
				throw new ParseException("Error type of op: = /" + type.name + " " + jjtn000.typeRight.name);
		}
		|
			"[" (<INTEGER_LITERAL >)? "]" (<ASSIGNMENT_EQUAL_OPERATOR > "{" ArrayInitializer() "}")?
		)?
	)*
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** struct declaration. */
void StructDeclaration() : 
{/*@bgen(jjtree) StructDeclaration */
        ASTStructDeclaration jjtn000 = new ASTStructDeclaration(JJTSTRUCTDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t = null;
	String id;
}
{/*@bgen(jjtree) StructDeclaration */
        try {
/*@egen*/
	t = "struct" id = MyID()
	{
		if (curEnv.contains(id))
			throw new ParseException("Redifine: "+ id);
		curEnv.put(id, new Type(t.image, true));	}
	StructBody()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** struct body. */
void StructBody() :
{/*@bgen(jjtree) StructBody */
        ASTStructBody jjtn000 = new ASTStructBody(JJTSTRUCTBODY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Env savedEnv = curEnv;
	curEnv = new Env(curEnv);
}
{/*@bgen(jjtree) StructBody */
        try {
/*@egen*/
	"{"
	StructDeclarations()	
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		curEnv = savedEnv;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** struct declarations. */
void StructDeclarations() : {/*@bgen(jjtree) StructDeclarations */
  ASTStructDeclarations jjtn000 = new ASTStructDeclarations(JJTSTRUCTDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclarations */
          try {
/*@egen*/
	  (StructParameter())*/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

/** struct parameter. */
void StructParameter() : {/*@bgen(jjtree) StructParameter */
  ASTStructParameter jjtn000 = new ASTStructParameter(JJTSTRUCTPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructParameter */
        try {
/*@egen*/
	UniversalDeclarator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** function declarator. */
void FunctionDeclarator() :
{/*@bgen(jjtree) FunctionDeclarator */
        ASTFunctionDeclarator jjtn000 = new ASTFunctionDeclarator(JJTFUNCTIONDECLARATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	String id;
}
{/*@bgen(jjtree) FunctionDeclarator */
        try {
/*@egen*/
	(t = <VOID > | t = <VARIABLE_TYPE >)
	id = MyID()
	{
		jjtn000.setType(t.image);
		jjtn000.setName(id);
		jjtn000.genInter();
		if (curEnv.contains(id))
			throw new ParseException("Redifine: "+ id);
		curEnv.put(id, new Type(t.image, true));
		Env savedEnv = curEnv;
		curEnv = new Env(curEnv);
	}
	"(" (FunctionParameterList())? ")" 
	{
		jjtn000.writeReturn();
	}
	FunctionBody()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		curEnv = savedEnv;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** function parameter list. */
void FunctionParameterList() : {/*@bgen(jjtree) FunctionParameterList */
  ASTFunctionParameterList jjtn000 = new ASTFunctionParameterList(JJTFUNCTIONPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionParameterList */
        try {
/*@egen*/
	FunctionParameter() ("," FunctionParameter())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** function parameter. */
void FunctionParameter() :
{/*@bgen(jjtree) FunctionParameter */
        ASTFunctionParameter jjtn000 = new ASTFunctionParameter(JJTFUNCTIONPARAMETER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	String id;
}
{/*@bgen(jjtree) FunctionParameter */
        try {
/*@egen*/
	(<CONST >)? t = <VARIABLE_TYPE > id = MyID()
	{
		jjtn000.setType(t.image);
		jjtn000.setName(id);
		jjtn000.genInter();
		
		if (curEnv.contains(id))
			throw new ParseException("Redifine: "+ id);
		curEnv.put(id, new Type(t.image, false));
	}
	(	  <ASSIGNMENT_EQUAL_OPERATOR > Expression()
	  | "[" (<INTEGER_LITERAL >)? "]" (<ASSIGNMENT_EQUAL_OPERATOR > "{" ArrayInitializer() "}")?
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** function body. */
void FunctionBody() : {/*@bgen(jjtree) FunctionBody */
  ASTFunctionBody jjtn000 = new ASTFunctionBody(JJTFUNCTIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionBody */
        try {
/*@egen*/
	"{" BlockStatements() "}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/** ************block*************** .*/

/** A block. */
void Block() : {/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
        try {
/*@egen*/
	"{" BlockStatements() "}"
<<<<<<< HEAD
	| Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
=======
	| BlockStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
>>>>>>> 9580b398b1229a0b1f7d88e5d0175d7b100038d1
/*@egen*/
}

/** block statements. */
void BlockStatements() : {/*@bgen(jjtree) BlockStatements */
  ASTBlockStatements jjtn000 = new ASTBlockStatements(JJTBLOCKSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BlockStatements */
        try {
/*@egen*/
	(BlockStatement())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** block statement. */
void BlockStatement() : {/*@bgen(jjtree) BlockStatement */
  ASTBlockStatement jjtn000 = new ASTBlockStatement(JJTBLOCKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BlockStatement */
        try {
/*@egen*/
	UniversalDeclarator()
	| Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** A statement. */
void Statement() : {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
        try {
/*@egen*/
	SimpleStatement()
	| IfStatement()
	| WhileStatement()
	| ForStatement()
	| ForeachStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** statement without trailing substatement(simple statement). */
void SimpleStatement() : {/*@bgen(jjtree) SimpleStatement */
  ASTSimpleStatement jjtn000 = new ASTSimpleStatement(JJTSIMPLESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleStatement */
        try {
/*@egen*/
	EmptyStatement()
	| LOOKAHEAD(10) (PostIncDecExpression() ";")
	| LOOKAHEAD(10) (PreIncDecExpression() ";")
	| LOOKAHEAD(10) (AssignmentExpression() ";")	
	| BreakStatement()
	| ContinueStatement()
	| ReturnStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** empty statement. */
void EmptyStatement() : {/*@bgen(jjtree) EmptyStatement */
  ASTEmptyStatement jjtn000 = new ASTEmptyStatement(JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EmptyStatement */
        try {
/*@egen*/
	";"/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/** if statement. */
void IfStatement() :
{/*@bgen(jjtree) IfStatement */
        ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraR;
}
{/*@bgen(jjtree) IfStatement */
        try {
/*@egen*/
	<IF > "(" paraR = Expression() ")"
	{
		if (jjtn000.typeRight != Type.Bool)
			throw new ParseException("Error type of ifStatement: " + jjtn000.typeRight.name);		
		Env savedEnv = curEnv;
		curEnv = new Env(curEnv);
		jjtn000.genInter(0, paraR);	}
	Block()
	{
<<<<<<< HEAD
	 	jjtn000.genTailLabel();	}
	(LOOKAHEAD(2) <ELSE > <IF > "(" Expression() ")" Block())* (<ELSE > Block())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
=======
	  	curEnv = savedEnv;	 		}
	(
		LOOKAHEAD(2) <ELSE > <IF >
		{
			jjtn000.genElseLabel();		}
		"(" paraR = Expression() ")"
		{
		  	jjtn000.genInter(0, paraR);
			if (jjtn000.typeRight != Type.Bool)
				throw new ParseException("Error type of ifStatement: " + jjtn000.typeRight.name);		
			savedEnv = curEnv;
			curEnv = new Env(curEnv);
		}
		Block()
		{
		  	curEnv = savedEnv;
		}
	)*
	(
		<ELSE >
		{
		  	jjtn000.genElseLabel();
			savedEnv = curEnv;
			curEnv = new Env(curEnv);
		}
		Block()
		{
		  	curEnv = savedEnv;
		}
	)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.genTailLabel();	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
>>>>>>> 9580b398b1229a0b1f7d88e5d0175d7b100038d1
/*@egen*/
}

/** A WhileStatement. */
void WhileStatement() : 
{/*@bgen(jjtree) WhileStatement */
        ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraR;
}
{/*@bgen(jjtree) WhileStatement */
        try {
/*@egen*/	
	<WHILE >
	{
		jjtn000.writeHeadLabel();
	}
	"(" paraR = Expression() ")" 
	{
		if (jjtn000.typeRight != Type.Bool)
			throw new ParseException("Error type of whileStatement: " + jjtn000.typeRight.name);		
		Env savedEnv = curEnv;
		curEnv = new Env(curEnv);
		jjtn000.genInter(0, paraR);		
	}
	Block()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.writeTailLabel();
<<<<<<< HEAD
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
=======
		curEnv = savedEnv;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
>>>>>>> 9580b398b1229a0b1f7d88e5d0175d7b100038d1
/*@egen*/
}

/** for statement. */
void ForStatement() : 
{/*@bgen(jjtree) ForStatement */
        ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	String id;
	Token t = null;
}
{/*@bgen(jjtree) ForStatement */
        try {
/*@egen*/
	
	<FOR >
	{
		//jjtThis.writeHeadLabel();
		Env savedEnv = curEnv;
		curEnv = new Env(curEnv);
	}
	"(" (t = <VARIABLE_TYPE >)? id = MyID()
		{
			Type type;
			if (t != null)
			{
			  	String s = t.image;					if (s.compareTo("int") == 0)
					type = Type.Int;
				else if (s.compareTo("char") == 0)
					type = Type.Char;
				else
					throw new ParseException("Invalid type in forStatement");
				curEnv.put(id, type);
			}
			else
			{
				type = curEnv.get(id);
				if (type == null)
					throw new ParseException("Undifine id in forStatement: " + id);			}		}
		<ASSIGNMENT_EQUAL_OPERATOR >
		paraL = Expression()
		{
			if ((type == Type.Int) && ((jjtn000.typeRight != Type.Int) && (jjtn000.typeRight != Type.Char)))
				throw new ParseException("Error type in forStatement: / " + type.name + " " + jjtn000.typeRight.name);
			if ((type == Type.Char) && (jjtn000.typeRight != Type.Char))
				throw new ParseException("Error type in forStatement: / " + type.name + " " + jjtn000.typeRight.name);		}
		<TO >
		paraR = Expression()
		{
			if ((type == Type.Int) && ((jjtn000.typeRight != Type.Int) && (jjtn000.typeRight != Type.Char)))
				throw new ParseException("Error type in forStatement: / " + type.name + " " + jjtn000.typeRight.name);
			if ((type == Type.Char) && (jjtn000.typeRight != Type.Char))
				throw new ParseException("Error type in forStatement: / " + type.name + " " + jjtn000.typeRight.name);		}
	")" 
	{
		jjtn000.genInter(id, paraL, paraR);
	}
	Block()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.writeTailLabel();
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** foreach statement. */
void ForeachStatement() : {/*@bgen(jjtree) ForeachStatement */
  ASTForeachStatement jjtn000 = new ASTForeachStatement(JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForeachStatement */
        try {
/*@egen*/
	<FOREACH > "(" <VARIABLE_TYPE > MyID() ":" MyID() ")" Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** break statement. */
void BreakStatement() : {/*@bgen(jjtree) BreakStatement */
  ASTBreakStatement jjtn000 = new ASTBreakStatement(JJTBREAKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BreakStatement */
        try {
/*@egen*/
	<BREAK > ";"/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** continue statement. */
void ContinueStatement() : {/*@bgen(jjtree) ContinueStatement */
  ASTContinueStatement jjtn000 = new ASTContinueStatement(JJTCONTINUESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ContinueStatement */
        try {
/*@egen*/
	<CONTINUE > ";"/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** return statement. */
void ReturnStatement() : 
<<<<<<< HEAD
{/*@bgen(jjtree) ReturnStatement */
        ASTReturnStatement jjtn000 = new ASTReturnStatement(JJTRETURNSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL;
}
{/*@bgen(jjtree) ReturnStatement */
        try {
=======
{/*@bgen(jjtree) ReturnStatement */
        ASTReturnStatement jjtn000 = new ASTReturnStatement(JJTRETURNSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL;
}
{/*@bgen(jjtree) ReturnStatement */
        try {
>>>>>>> 9580b398b1229a0b1f7d88e5d0175d7b100038d1
/*@egen*/
	<RETURN >
	(
		paraL = Expression()
		{
<<<<<<< HEAD
			jjtn000.genInter(paraL, 0);		}
	)? ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
=======
			jjtn000.genInter(paraL, 0);
		}
	)?
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
>>>>>>> 9580b398b1229a0b1f7d88e5d0175d7b100038d1
/*@egen*/
	
}

/** comment statement. */
void CommentStatement() : {/*@bgen(jjtree) CommentStatement */
  ASTCommentStatement jjtn000 = new ASTCommentStatement(JJTCOMMENTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CommentStatement */
        try {
/*@egen*/
	";"/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** ************Expressions*************** .*/

/** An Expression. */
int Expression() :{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	LOOKAHEAD(5)
	AssignmentExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000.getPara();
	}
	| ConditionalExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000.getPara();	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** assignment expression. */
int AssignmentExpression() :
{/*@bgen(jjtree) AssignmentExpression */
        ASTAssignmentExpression jjtn000 = new ASTAssignmentExpression(JJTASSIGNMENTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String lhs;
	Token op = null;
	int paraR;
}
{/*@bgen(jjtree) AssignmentExpression */
        try {
/*@egen*/
	lhs = LeftSide() (op = <ASSIGNMENT_OPERATOR > | op = <ASSIGNMENT_EQUAL_OPERATOR >) paraR = Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		Type type = curEnv.get(lhs);
		if (type == null)
			throw new ParseException("Undifine: "+ lhs);
		if (type.isFunc)
			throw new ParseException("Invalid parameter: "+ lhs);
		if ((type == Type.Bool) && (jjtn000.typeRight != Type.Bool))
			throw new ParseException("Error type of op: " + op.image + " / "+ type.name + " " + jjtn000.typeRight.name);
		if ((type != Type.Bool) && (jjtn000.typeRight == Type.Bool))
			throw new ParseException("Error type of op: " + op.image + " / "+ type.name + " " + jjtn000.typeRight.name);
		if ((type == Type.Char) && (jjtn000.typeRight == Type.Real))
			throw new ParseException("Error type of op: " + op.image + " / "+ type.name + " " + jjtn000.typeRight.name);
		if ((type == Type.Int) && (jjtn000.typeRight == Type.Real))
			throw new ParseException("Error type of op: " + op.image + " / "+ type.name + " " + jjtn000.typeRight.name);
		jjtn000.typeRight = type;						
		jjtn000.setLeftSide(lhs);
		jjtn000.setOp(op.image);
		return jjtn000.genInter(0, paraR);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** conditional expression. */
int ConditionalExpression() : {/*@bgen(jjtree) ConditionalExpression */
  ASTConditionalExpression jjtn000 = new ASTConditionalExpression(JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpression */
        try {
/*@egen*/
	ConditionalOrExpression() ("?" Expression() ":" Expression())?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000.getPara();	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** conditional or expression. */
int ConditionalOrExpression() :
{/*@bgen(jjtree) ConditionalOrExpression */
        ASTConditionalOrExpression jjtn000 = new ASTConditionalOrExpression(JJTCONDITIONALOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) ConditionalOrExpression */
        try {
/*@egen*/
	paraL = ConditionalAndExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		"||" paraR = ConditionalAndExpression()
		
		{
			if ((typeLeft != Type.Bool) || (jjtn000.typeRight != Type.Bool))
				throw new ParseException("Error type of op: || / " + typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.Bool;			paraL = jjtn000.genInter(paraL, paraR);		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** conditional and expression. */
int ConditionalAndExpression() :
{/*@bgen(jjtree) ConditionalAndExpression */
        ASTConditionalAndExpression jjtn000 = new ASTConditionalAndExpression(JJTCONDITIONALANDEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) ConditionalAndExpression */
        try {
/*@egen*/
	paraL = InclusiveOrExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		"&&" paraR = InclusiveOrExpression()
		{
			if ((typeLeft != Type.Bool) || (jjtn000.typeRight != Type.Bool))
				throw new ParseException("Error type of op: && / " + typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.Bool;
			paraL =  jjtn000.genInter(paraL, paraR);		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** inclusive or expression. */
int InclusiveOrExpression() : 
{/*@bgen(jjtree) InclusiveOrExpression */
        ASTInclusiveOrExpression jjtn000 = new ASTInclusiveOrExpression(JJTINCLUSIVEOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) InclusiveOrExpression */
        try {
/*@egen*/
	paraL = ExclusiveOrExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		"|" paraR = ExclusiveOrExpression()
		{
			if (typeLeft != Type.Int && typeLeft != Type.Char)
				throw new ParseException("Error type of op: | / " + typeLeft.name + " " + jjtn000.typeRight.name);
			if (jjtn000.typeRight != Type.Int && jjtn000.typeRight != Type.Char)
				throw new ParseException("Error type of op: | / " + typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.max(typeLeft, jjtn000.typeRight);
			paraL =  jjtn000.genInter(paraL, paraR);
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** exclusive or expression. */
int ExclusiveOrExpression() :
{/*@bgen(jjtree) ExclusiveOrExpression */
        ASTExclusiveOrExpression jjtn000 = new ASTExclusiveOrExpression(JJTEXCLUSIVEOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) ExclusiveOrExpression */
        try {
/*@egen*/
	paraL = AndExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		"^" paraR = AndExpression()
		{
			if (typeLeft != Type.Int && typeLeft != Type.Char)
				throw new ParseException("Error type of op: ^ / " + typeLeft.name + " " + jjtn000.typeRight.name);
			if (jjtn000.typeRight != Type.Int && jjtn000.typeRight != Type.Char)
				throw new ParseException("Error type of op: ^ / " + typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.max(typeLeft, jjtn000.typeRight);
			paraL =  jjtn000.genInter(paraL, paraR);
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** and expression. */
int AndExpression() :
{/*@bgen(jjtree) AndExpression */
        ASTAndExpression jjtn000 = new ASTAndExpression(JJTANDEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) AndExpression */
        try {
/*@egen*/
	paraL = EqualityExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		"&" paraR = EqualityExpression()
		{
			if (typeLeft != Type.Int && typeLeft != Type.Char)
				throw new ParseException("Error type of op: & / " + typeLeft.name + " " + jjtn000.typeRight.name);
			if (jjtn000.typeRight != Type.Int && jjtn000.typeRight != Type.Char)
				throw new ParseException("Error type of op: & / " + typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.max(typeLeft, jjtn000.typeRight);
			paraL =  jjtn000.genInter(paraL, paraR);
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** equality expression. */
int EqualityExpression() : 
{/*@bgen(jjtree) EqualityExpression */
        ASTEqualityExpression jjtn000 = new ASTEqualityExpression(JJTEQUALITYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int paraL, paraR;
	Token op = null;
	Type typeLeft;
}
{/*@bgen(jjtree) EqualityExpression */
        try {
/*@egen*/
	paraL = RelationalExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		(op = "==" | op = "!=") paraR = RelationalExpression()
		{
			if ((typeLeft == Type.Bool) && Type.numeric(jjtn000.typeRight))
				throw new ParseException("Error type of op: " + op.image + " / "+ typeLeft.name + " " + jjtn000.typeRight.name);
			if ((jjtn000.typeRight == Type.Bool) && Type.numeric(typeLeft))
				throw new ParseException("Error type of op: " + op.image + " / "+ typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.Bool;
			jjtn000.setOp(op.image);
			paraL =  jjtn000.genInter(paraL, paraR);
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** relational expression. */
int RelationalExpression() :
{/*@bgen(jjtree) RelationalExpression */
        ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token op = null;
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) RelationalExpression */
        try {
/*@egen*/
	paraL = ShiftExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		(op = "<"| op = ">" | op = "<=" | op = ">=") paraR = ShiftExpression()
		{
			if ((!Type.numeric(typeLeft)) || (!Type.numeric(jjtn000.typeRight)))
				throw new ParseException("Error type of op: " + op.image + " / "+ typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.Bool;
			jjtn000.setOp(op.image);
			paraL =  jjtn000.genInter(paraL, paraR);
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** shift expression. */
int ShiftExpression() :
{/*@bgen(jjtree) ShiftExpression */
        ASTShiftExpression jjtn000 = new ASTShiftExpression(JJTSHIFTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token op = null;
	int paraL, paraR;
	Type typeLeft;
}
{/*@bgen(jjtree) ShiftExpression */
        try {
/*@egen*/
	paraL = AdditiveExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		(op = "<<" | op = ">>") paraR = AdditiveExpression()
		{
			if (typeLeft != Type.Int && typeLeft != Type.Char)
				throw new ParseException("Error type of op: " + op.image + " / "+ typeLeft.name + " " + jjtn000.typeRight.name);
			if (jjtn000.typeRight != Type.Int && jjtn000.typeRight != Type.Char)
				throw new ParseException("Error type of op: " + op.image + " / "+ typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = Type.Int;
			jjtn000.setOp(op.image);
			paraL =  jjtn000.genInter(paraL, paraR);
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** additive expression. */
int AdditiveExpression() :
{/*@bgen(jjtree) AdditiveExpression */
        ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(JJTADDITIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token op = null;
	int paraL, paraR;
	Type typeLeft, temp;
}
{/*@bgen(jjtree) AdditiveExpression */
        try {
/*@egen*/
	paraL = MultiplicativeExpression()
	{
		typeLeft = jjtn000.typeRight;
	}
	(
		(op = "+" | op = "-") paraR = MultiplicativeExpression()
		{
			jjtn000.setOp(op.image);
			paraL =  jjtn000.genInter(paraL, paraR);
			temp = Type.max(typeLeft, jjtn000.typeRight);
			if (temp == null)
				throw new ParseException("Unmatched type: "+ typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = temp;
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** multiplicative expression. */
int MultiplicativeExpression() :
{/*@bgen(jjtree) MultiplicativeExpression */
        ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(JJTMULTIPLICATIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token op = null;
	int paraL, paraR;
	Type typeLeft, temp;
}
{/*@bgen(jjtree) MultiplicativeExpression */
        try {
/*@egen*/
	paraL = UnaryExpression()
	{
		typeLeft = jjtn000.typeRight;	}
	(
		(op = "*" | op = "/" | op = "%") paraR = UnaryExpression()
		{
			jjtn000.setOp(op.image);
			paraL = jjtn000.genInter(paraL, paraR);
			temp = Type.max(typeLeft, jjtn000.typeRight);
			if (temp == null)
				throw new ParseException("Unmatched type: "+ typeLeft.name + " " + jjtn000.typeRight.name);
			typeLeft = temp;
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.typeRight = typeLeft;
		return paraL;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}


/** unary expression. */
int UnaryExpression() : 
{/*@bgen(jjtree) UnaryExpression */
        ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token op = null;
	int paraR;
}
{/*@bgen(jjtree) UnaryExpression */
        try {
/*@egen*/
	SimpleUnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000.getPara();	}
	| op = "+" paraR = UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (!Type.numeric(jjtn000.typeRight))
			throw new ParseException("Error type of op: +  / " +  jjtn000.typeRight.name);
		jjtn000.setOp(op.image);
		return jjtn000.genInter(0, paraR);	}
	| op = "-" paraR = UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (!Type.numeric(jjtn000.typeRight))
			throw new ParseException("Error type of op: -  / " + jjtn000.typeRight.name);
		jjtn000.setOp(op.image);
		return jjtn000.genInter(0, paraR);	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** PreIncDecExpression. */
void PreIncDecExpression() : {/*@bgen(jjtree) PreIncDecExpression */
  ASTPreIncDecExpression jjtn000 = new ASTPreIncDecExpression(JJTPREINCDECEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PreIncDecExpression */
        try {
/*@egen*/
	("--" | "++") LeftSide()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** PostIncDecExpression. */
void PostIncDecExpression() : {/*@bgen(jjtree) PostIncDecExpression */
  ASTPostIncDecExpression jjtn000 = new ASTPostIncDecExpression(JJTPOSTINCDECEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PostIncDecExpression */
        try {
/*@egen*/
	LeftSide() ("--" | "++")/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** unary expression not plus minus(simpleUnaryExpression). */
int SimpleUnaryExpression() : 
{/*@bgen(jjtree) SimpleUnaryExpression */
        ASTSimpleUnaryExpression jjtn000 = new ASTSimpleUnaryExpression(JJTSIMPLEUNARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token op = null;
	int paraR;
}
{/*@bgen(jjtree) SimpleUnaryExpression */
        try {
/*@egen*/
	Primary()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000.getPara();
	}
	| op = "~" paraR = UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (jjtn000.typeRight != Type.Int && jjtn000.typeRight != Type.Char)
			throw new ParseException("Error type of op: ~ / " + jjtn000.typeRight.name);
		jjtn000.setOp(op.image);
		return jjtn000.genInter(0, paraR);
	}
	| op = "!" paraR = UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (Type.numeric(jjtn000.typeRight))
			throw new ParseException("Error type of op: ! / " + jjtn000.typeRight.name);
		jjtn000.setOp(op.image);
		return jjtn000.genInter(0, paraR);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** primary. */
int Primary() :
{/*@bgen(jjtree) Primary */
        ASTPrimary jjtn000 = new ASTPrimary(JJTPRIMARY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t1;
	String lhs;
}
{/*@bgen(jjtree) Primary */
        try {
/*@egen*/
  	t1 = <INTEGER_LITERAL >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t1.image);
		jjtn000.typeRight = Type.Int;
		return jjtn000.genInter();
	}
	| t1 = <REAL_LITERAL >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t1.image);		
		jjtn000.typeRight = Type.Real;
		return jjtn000.genInter();
	}
	| t1 = <BOOLEAN_LITERAL >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t1.image);		
		jjtn000.typeRight = Type.Bool;
		return jjtn000.genInter();
	} 
	| t1 = <CHARACTER_LITERAL >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t1.image);		
		jjtn000.typeRight = Type.Char;
		return jjtn000.genInter();
	}	
	| lhs = LeftSide() (FunctionInvoke())?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		Type type = curEnv.get(lhs); 
		if (type == null)
			throw new ParseException("Undifine: "+ lhs);
		if (type.isFunc)
			throw new ParseException("Invalid parameter: "+ lhs);
		jjtn000.typeRight = type;
		jjtn000.setName(lhs);
		return jjtn000.genInter();		
	}
	| "(" Primary2()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** FunctionInvoke. */
void FunctionInvoke() : {/*@bgen(jjtree) FunctionInvoke */
  ASTFunctionInvoke jjtn000 = new ASTFunctionInvoke(JJTFUNCTIONINVOKE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionInvoke */
        try {
/*@egen*/
	"(" (Expression() ("," Expression())*)?	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** primary2. */
void Primary2() : {/*@bgen(jjtree) Primary2 */
  ASTPrimary2 jjtn000 = new ASTPrimary2(JJTPRIMARY2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Primary2 */
        try {
/*@egen*/
	Expression() ")"
	| <VARIABLE_TYPE > ")" SimpleUnaryExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ //cast expression}

/** left side. */
String LeftSide() :
{/*@bgen(jjtree) LeftSide */
        ASTLeftSide jjtn000 = new ASTLeftSide(JJTLEFTSIDE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t1;
	Token t2;
}
{/*@bgen(jjtree) LeftSide */
        try {
/*@egen*/
	t1 = <IDENTIFIER>
	{
		jjtn000.setName(t1.image);
		return t1.image;
	}
	(
		"." t2 = <IDENTIFIER >
		{
			jjtn000.setName(t1.image + "." + t2.image);
		}
		|
		"[" Expression() "]"
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** An Identifier. */
String MyID() :
{/*@bgen(jjtree) MyID */
        ASTMyID jjtn000 = new ASTMyID(JJTMYID);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) MyID */
        try {
/*@egen*/
	t = <IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t.image);
		return t.image;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**bugs remain:*/
/**
	s[i];
	s[i++];
*/